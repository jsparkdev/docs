---
title: pnpm
description: pnpm이 패키지를 관리하는 방법에 대해 알아봅니다.
draft: true
---

## 의존성을 관리하는 방법

- npm, yarn이 의존성을 node_modules에 직접 설치하는 반면, pnpm은 중앙 저장소 (pnpm store path로 확인 가능)에 의존성을 설치하고, .pnpm 디렉터리로 의존성을 가져오기 위해 하드 링크를 사용합니다. 그리고 각 의존성을 심볼릭 링크로 연결합니다.
- 프로젝트에서 직접 설치한 의존성은 node_modules에 심볼릭 링크로 존재하며, 이 링크들은 .pnpm 디렉터리에 있는 의존성 링크들을 가리킵니다.
- 하위 의존성 (직접 설치한 의존성이 사용하는 의존성)은 node_modules 아래 .pnpm 디렉터리에 심볼릭 링크로 존재하며, 각 링크는 중앙 저장소의 실제 파일을 가리킵니다.
- 하위 의존성을 .pnpm 디렉터리로 격리한 이유는, 직접 설치한 의존성과의 버전 충돌을 피하여 의존성의 정확한 버전을 사용하기 위함입니다.


즉, 중앙 저장소에서 .pnpm으로 의존성을 가져올때만 하드링크로 연결하고, 그 후 의존성끼리 연결할 때는 심볼릭 링크 사용.

노드모듈즈 최상위에 보이는 패키지(디렉터리)이름은 모두 심볼릭 링크들임.
얘네들이 가리키는건 모두 .pnpm에 있다.

이 심볼릭 링크는 우리가 앱에서 직접 접근해야하는 패키지임.
이 심볼릭 링크는 디렉터리이며, 들어가보면 npm 패키지 구조 그대로 유지된걸 볼 수 있지만, 노드모듈즈 폴더는 없음.
왜냐면 얘는 그냥 심볼릭 링크기 때문임. 실제 위치가 아니라는거임.
즉, .pnpm 폴더에 다 숨겨놓음.
.pnpm은 예전 npm, yarn classic이 사용하던 플랫 구조를 사용함. 그래서 패키지 찾고싶으면 다음 패턴을 보면 됨.
.pnpm/패키지이름@버전/node_modules/패키지이름 근데 사실 이거 심볼링링크에 마우스대면 다 나옴. 근데 여기도 보면 노드모듈즈 없거나 니가 원하는 파일들은 없을거임.
실제는 .pnpm/패키지이름@버전/node_modules에 있음.
근데 이게 말이안되는게 패키지랑 패키지의 하위 종속성이 왜 같은 레벨에 있음?
뭔가 비빔밥이랑 고추장, 밥, 나물이 다 같은레벨에 있음.
이 모든 재료 종속성들도 심볼릭 링크임. 이를 통해 심볼릭 링크들의 순환 참조를 방지함.

D
- —dir: pnpm을 현재 디렉터리가 아닌 특정 디렉터리에서 실행
- —workspace-root: pnpm을 워크스페이스 루트에서 실행

pnpm은 run 없이 커맨드 실행 가능. 왜냐면 알 수 없는 명령어를 사용하면 script중에서 찾기 때문.
스크립트도 없으면 쉘 스크립트라고 가정하고 실행함.

즉, Pnpm 명령어 이건 다음과 같이 동작함.
1. 내장된 명령어 인지 확인
2. 내장된게 아니면 스크립트 이름을 찾아 실행 (pnpm run)
3. 스크립트에도 없으면 쉘스크립트처럼 실행함. 즉 node_modules/.bin에서 찾음. (Pnpm exec)

라이프사이클
devPreinstall: 로컬에서 install 하기 전에 실행됨.

Pnpm add를 워크스페이스에서 실행하면 최신 버전을 설치하는게 아니라 여러 패키지 중에 이 의존성을 사용하는 패키지가 있는지 확인한 후, 동일한 버전을 설치함.

pnpm add ./package.tar.gz
pnpm add ./some-directory
이렇게 로컬로 만든 디펜던시도 설치 가능

Pnpmp update —interactive 
직접 선택해서 업데이트

Pnpm link 디렉터리
 심볼릭 링크 생성
Projects/bar 에서 pnpm link ../foo를 실행하면 bar/node_modules/foo 심볼릭 링크가 생성됨.

Pnpm link
해당 패키지 (이 명령을 실행한 위치)를 글로벌 링크 저장소에 등록합니다.
그래서 로컬에서 이걸 링크로 연결해서 사용 가능.

Pnpm link 패키지이름
Npm 레지스트리 대신 글로벌 링크 저장소에 등록된 (위 명령을 통해 ) 패키지를 사용한다는 점 제외하면 pnpm add랑 같은듯.

Pnpm link는 그러면 로컬에서 개발중인 패키지 테스트용으로 좋다. 특히, 버전 업데이트 후 배포 전에 테스트하는 용도로 좋은듯.

즉 인자가 있으면 글로벌 링크 저장소에 특정 패키지를 등록하는거고, 없으면 자기 자신을 등록하는거임.

패키지가 bin 필드를 가지고 있다면, 어디서든 전역적으로 사용가능. (-g 와 비슷한 역할)
그리고 심볼릭 링크로 연결되었으므로 로컬 파일을 수정하면, 이 패키지를 사용하는 프로젝트에 즉각 반영됨.
저장소에서 내리고 싶다면 pnpm unlink

Pnpm import는 다른 패키지의 lock 파일을 마이그레이션함.


Pnpm patch로 현재 프로젝트에서 사용중인 패키지의 수정 버전을 체험할 수 있음.
1. 프로젝트에서 사용중인 패키지를 패치함 pnpm patch is-even
2. 그러면 임시 디렉터리에 해당 패키지의 파일이 생김. 이걸 변경하고 터미널에 나와있는대로 pnpm patch-commit 실행
3. 그리고 계속 사용 ㄱㄱ 그러면 패치된 버전으로 사용됨. 물론 패치 관련 파일이 생기지만.
4. 그리고 다시 원래대로 돌아가고 싶으면 (변경된거 모두 제거) pnpm patch-remove

Pnpm cli 옵션

실행 위치 정하는 애들
—dir
—workspace-root
—filter

라이프사이클 스크립트


npm기본
스크립트 이름 만들고 pre, post 붙여서 커스텀 라이프 사이클 스크립트 만들 수 있다.
pre는 전에, post는 후에 실행

근데 기본제공 라이프사이클 스크립트도 있음.
- prepare: 패키지가 패키징되기 전엥 실행 (publish나 pack 전에 실행), 로컬에서 의존성 전체 설치 시 실행 (install), prepare - prepublishOnly 순으로 실행
- prepublishOnly: npm publish 시, prepare, pack 되기 전에 실행

직접 실행해봄
- Pnpm install 해봄: 모든 종속성 설치 후 preinstall - postinstall - prepare  실행됨, 터미널 출력이 그렇다는거고 실제로는 preinstall - install- post install - prepare
- Pnpm pack 해봄: prepack - prepare - postpack - 그다음 압축함.
- Pnpm publish해봄: prepublishOnly 먼저 실행 - prepack - prepare - postpack 실행 - 압축

스크립트
exec로 쉘 명령을 실행함
node_modules/.bin가 PATH에 추가되어서 가능함.
쉘을 실행한다는건 터미널에서 명령을 실행한다는 거임.
Pnpm exec eslint 근데 eslint 스크립트가 중복되지않으면 exec를 생략할 수 있다.
Pnpm eslint
모든 옵션인자는 exec 앞에 와야함. 뒤에오면 진짜 인자로 인식함.

Pnpm dlx
패키지를 종속성으로 설치하지 않고, 레지스트리에서 바로 가져와 바이너리를 실행.
